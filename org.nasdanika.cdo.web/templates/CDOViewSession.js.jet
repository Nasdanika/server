<%@ jet package="org.nasdanika.cdo.web.routes" class="CDOViewSessionModuleGenerator" skeleton="Generator.skeleton" %>
<%
	org.nasdanika.web.HttpServletRequestContext context = (org.nasdanika.web.HttpServletRequestContext) args[0];
	org.eclipse.emf.cdo.view.CDOView cdoView = (org.eclipse.emf.cdo.view.CDOView) args[1]; 
	String webSocketUrl = (String) args[2];
%>
define(["q"], function(Q) {

	<%@ include file="arrayDelta.js" %> 
	
	// prepares object for sending to the server side by replacing model objects with paths
	function marshal(obj) {
		if (Array.isArray(obj)) {
			var ret = [];
			for (var i in obj) {
				ret.push(marshal(obj[i]));
			}	
			return ret;		
		} 
		
		if (typeof obj === "object") {
			if (obj.hasOwnProperty("$path")) {
				return { $path : obj.$path };
			}
			var ret = {};
			for (var k in obj) {
				ret[k] = marshal(obj[k]);
			}	
			return ret;		
		}	
		
		return { value : obj };			
	}
	
	// unmarshals by resolving paths to promises
	function unmarshal(obj, isValue) {
		if (obj === undefined) {
			return obj;
		}
		
		if (Array.isArray(obj)) {
			var ret = [];
			var hasPromises = false;
			for (var i in obj) {
				var e = unmarshal(obj[i], false);
				if (Q.isPromise(e)) {
					hasPromises = true;
				}
				ret.push(e);
			}	
			return hasPromises ? Q.all(ret) : ret;		
		} 
		
		if (isValue) {
			if (typeof obj === "object") {
				var pending = [];
				var ret = {};
				for (var k in obj) {
					var e = unmarshal(obj[k], false);
					if (Q.isPromise(e)) {
						pending.push(e.then(function(k, v) { ret[k] = v; }.bind(this, k)));
					} else {
						ret[k] = e;
					}
				}	
				return pending.length==0 ? ret : Q.all(pending).thenResolve(ret);		
			}
						
			return obj;			
		}
				
		if (obj.hasOwnProperty("$path")) {
			return Q.promise(function(resolve, reject, notify) {
				require([obj.$path+".js"], function(mod) {
					resolve(mod);
				});																	        					
			});
		}
		
		return unmarshal(obj.value, true);	
	}
	
	var deferredCounter = 0;
	var deferreds = {};
	
	var sessionSocket = new WebSocket("<%=webSocketUrl%>");
	sessionSocket.onMessage(function(event) {
		var response = JSON.parse(event.data);
		var deferred = deferreds[response.id];
		if (deferred) {
			if (response.hasOwnProperty("progressNotification")) {
				deferred.notify(response.progressNotification);
			} else if (response.hasOwnProperty("reason")) {
				deferred.reject(response.reason); //reject(unmarshal(response.reason, false));
				delete deferreds[response.id];
	    	} else if (response.hasOwnProperty('validationResults')) { 
	    		deferred.reject({ validationFailed:true, validationResults: unmarshal(response.validationResults, false) });
	    		delete deferreds[response.id];
	    	} else { 
	    	 	if (response.hasOwnProperty('deltas')) {
	    	 		var deltaPromises = [];
	        		for (var k in response.deltas) {
	        			if (session.sessionObjects.hasOwnProperty(k)) {
	        				if (response.deltas[k] === 'detached') {
	        					delete session.sessionObjects[k];
	        				} else {
		        				var deltaPromise = session.sessionObjects[k].applyDelta(response.deltas[k]);
		        				if (Q.isPromise(deltaPromise)) {
		        					deltaPromises.push(deltaPromise);
		        				}
		        			}
	        			}
	        		}
	        	}
	        	if (deltaPromises.length===0) {
	        		deferred.resolve(unmarshal(response.result, false));
	        	} else {
	    			Q.all(deltaPromises).then(function() { deferred.resolve(unmarshal(response.result, false)); });
	    		}
	    	}
		} else {
			console.log("Invalid response id: "+response);
		}
	});

	var session = {
		sessionObjects : {},
		
		arrayDelta : function(original, modified) {
			return _arrayDelta(original, modified, 0, 0, 0);
		},
		
		// TODO - resources and resource folders - promise of resource content (lazy-ref)
	
		// Posts local changes to the server, including operation target, name, and arguments, if specified.
		// Applies returned server-side changes to the model
		// Returns a promise which is fulfilled with the operation result or undefined when store operation completes.
		apply : function(target, operation, opArgs) {
			var deferred = Q.defer();
			var deferredId = deferredCounter++;
			deferreds[deferredId] = deferred;
			var applyData = { 
				id: deferredId 
			};			
			
			if (target) {
				applyData.target = target;
				applyData.operation = operation;
				applyData.args = [];
				for (var ak in opArgs) {
					applyData.args.push(marshal(opArgs[ak]));
				}
			}
			applyData.deltas = {};
			for (var k in session.sessionObjects) {
				applyData.deltas[k] = session.sessionObjects[k].delta;
			}
			
			sessionSocket.send(JSON.stringify(applyData));
			return deferred.promise;
		},
			
		// Updates model from the server if there are no local changes.
		// Applies returned server-side changes to the model
		// Returns a boolean promise which is fulfilled with true if data was loaded from the server, and false if there were local changes and the model was not updated.
		refresh : function() {
			for (var k in session.sessionObjects) {
				for (var l in session.sessionObjects[k].delta) {
					return Q(false);
				}
			}
			var deferred = Q.defer();
			var deferredId = deferredCounter++;
			deferreds[deferredId] = deferred;
			var applyData = ;			
			
			sessionSocket.send(JSON.stringify({ 
				id: deferredId 
			}));
			return deferred.promise;
		}		
	};	
	
	return session;
});
## Web development

A typical Nasdanika Foundation Server CDO Web Application consists of multiple cross-referencing Single-Page Applications generated by [[routeOperations.md|route operations]] of model objects residing in a CDO repository, and leveraging other route operations, [[javascriptApi.md|JavaScript API]] and [[forms.md|form operations]]. 

For example, a simple banking application could be structured as follows:

* ``Guest`` object, used as an unathenticated principal would have a ``Home route`` rendering the landing page with a login form rendered from a ``login`` operation metadata and annotations, and invoking the ``login`` operation on submit through the JavaScript API. 
* On successful login the browser would navigate to the ``Customer`` home page displaying a summary of customer accounts.
* A click on account would navigate to the ``Account`` home page, which may allow to dynamically select statement transactions to browse. This functionality would use, say [Knockout.js](http://knockoutjs.com/) bindings to the JavaScript object model to retrieve a list of transactions for a particular statement.  
       
       
### Choosing between KnockoutJS and AngularJS

[[bundle>org.nasdanika.web/doc/html.md|HTML API]] and form generators provide support for [AngularJS](https://angularjs.org/) and KnockoutJS. Whether to use one or the other depends on the way a particular single-page application communicates with the server side. 

If communication is performed through [[javascriptApi.md|JavaScript API]], then KnockoutJS is a better choice because:
* The JavaScript API is asynchronous and leverages promises. Asynchronous communication may interfere with AngularJS' digest cycle if not coded correctly. 
* In this case only a part of AngularJS functionality will be leveraged.
* JavaScript API is implemented as [AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md)/[RequireJS](http://requirejs.org/) modules, KnockoutJS also supports [AMD with RequireJS](http://knockoutjs.com/documentation/amd-loading.html). As such, application code can declare dependencies on repository objects and KnockoutJS (ko) with ``requirejs([dependencies], function() {...})``. AngularJS has its own module system and marrying the JavaScript API with AngularJS is a bit more involved.  
* KnockoutJS is better at reporting binding problems, so troubleshooting might be a bit easier.

In the case of use of operation routes which produce/consume JSON, AngularJS and its ``$http`` service can be a better choice. 

Choice between JavaScript API and route operations depends on the following factors:

* Can the domain model act as a view model? If the view model is very different from the domain model, then it is better to use route operations producing the view model. Initial view model can be retrieved from a read (GET) operation. Update (PUT, POST, DELETE) operations can take input data, modify the server-side model, and then return an updated view model, possibly invoking the read operation internally. 
* Progress notifications. The JavaScript API provides support for progress notifications for long-running operations. If this functionality is important, then JavaScript API shall be used. If the view model is different from the domain model, then view-model producing operations can be invoked through the JavaScript API.

        
       